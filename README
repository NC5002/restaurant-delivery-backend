**

# üçî Backend para Sistema de Delivery de Restaurante

Este repositorio contiene el backend para un sistema de gesti√≥n de delivery, desarrollado como parte del Pr√°cticum 3. La aplicaci√≥n est√° construida sobre una arquitectura de microservicios utilizando **Spring Boot** y **Java**, completamente contenerizada con **Docker** y automatizada con **GitHub Actions**.


# üìù Descripci√≥n del Proyecto y Proceso de Creaci√≥n

### Informaci√≥n del Estudiante

-   **Nombre:** Nicole Alexandra Calvas Echeverr√≠a
    
-   **Universidad:** UTPL
    
-   **Carrera:** Transformaci√≥n Digital de Empresas
    

### Informaci√≥n de la Empresa

-   **Nombre de la Empresa:** Come en Casa
    
-   **Descripci√≥n:** Restaurante
    

### Mapa de Capacidades y Aplicaci√≥n Objetivo

-   **Mapa de Capacidades:** El mapa de capacidades generado para la empresa se encuentra documentado en el `README.md` del [repositorio del frontend](https://github.com/NC5002/restaurant-delivery-app).
    
-   **Aplicaci√≥n Objetivo:**
    
    > La aplicaci√≥n objetivo es un sistema de gesti√≥n de delivery para el restaurante. Su prop√≥sito es digitalizar y optimizar el proceso de pedidos a domicilio, abordando directamente las capacidades de 'Gesti√≥n de Men√∫' y 'Procesamiento de √ìrdenes' identificadas en el mapa de capacidades. Esto permite a la empresa expandir su alcance, mejorar la eficiencia operativa y ofrecer una mejor experiencia al cliente.
    

### Proceso de Creaci√≥n del Backend

El desarrollo de este backend se centr√≥ en construir una soluci√≥n robusta, escalable y mantenible, siguiendo las mejores pr√°cticas de la industria para sistemas distribuidos.

## üèõÔ∏è Arquitectura de Microservicios

Se opt√≥ por una arquitectura de microservicios para desacoplar las responsabilidades del sistema, permitiendo un desarrollo y despliegue independiente de cada componente. La arquitectura consta de:

-   **Servidor de Descubrimiento (Discovery Service):** Implementado con _Spring Cloud Netflix Eureka_, act√∫a como el directorio telef√≥nico del sistema, permitiendo que los servicios se encuentren din√°micamente.
    
-   **API Gateway (Gateway Service):** Construido con _Spring Cloud Gateway_, sirve como el √∫nico punto de entrada para todas las peticiones externas. Se encarga de enrutar el tr√°fico al microservicio correspondiente y de centralizar la seguridad. Se implement√≥ un filtro de autenticaci√≥n basado en _JSON Web Tokens (JWT)_ para proteger los endpoints.
    
-   **Servicio de Cat√°logo (Catalog Service):** Gestiona toda la l√≥gica de negocio relacionada con los productos, incluyendo platillos (Dish) y categor√≠as (Category). Expone una API REST para operaciones CRUD.
    
-   **Servicio de √ìrdenes (Order Service):** Dise√±ado para gestionar las √≥rdenes de los clientes. Se implement√≥ la comunicaci√≥n entre servicios mediante un _cliente Feign_, permitiendo que el servicio de √≥rdenes consulte la disponibilidad y el precio de los platillos en el servicio de cat√°logo antes de procesar un pedido.
## ‚öôÔ∏è Integraci√≥n Continua y Entrega Continua (CI/CD)

Para cumplir con los objetivos de aprendizaje de la unidad, se implement√≥ un pipeline de CI/CD completo utilizando **GitHub Actions**.

-   **Integraci√≥n Continua (CI):** Cada `push` a la rama `main` dispara un workflow que compila cada microservicio y ejecuta sus pruebas unitarias y de integraci√≥n de forma autom√°tica. Esto asegura que nuevo c√≥digo no introduzca regresiones.
    
-   **Entrega Continua (CD):** Si las pruebas son exitosas, el workflow procede a construir im√°genes de Docker optimizadas para cada servicio (usando Dockerfiles multi-etapa) y las publica en **GitHub Container Registry (GHCR)**.
    

Este pipeline garantiza que siempre haya una versi√≥n estable y probada del software lista para ser desplegada.
## üåê Estado Actual y Conexi√≥n con Frontend

El backend est√° **100% funcional**. Todos los servicios se comunican correctamente, la seguridad est√° implementada y el pipeline de CI/CD automatiza el proceso de construcci√≥n y publicaci√≥n.

El frontend, desarrollado en React, se encuentra en un repositorio separado. Aunque la conexi√≥n final entre ambos no est√° implementada en este proyecto, el backend expone una API REST completamente funcional y documentada, lista para ser consumida.

-   **Repositorio Frontend (React):** [https://github.com/NC5002/restaurant-delivery-app](https://github.com/NC5002/restaurant-delivery-app)
    

### ‚ö†Ô∏è Nota sobre el Despliegue en Railway

> Se intent√≥ realizar el despliegue opcional en la plataforma Railway para obtener el punto extra. Se logr√≥ desplegar la base de datos MySQL, pero al intentar desplegar los microservicios desde las im√°genes de Docker publicadas en GHCR, la opci√≥n no estaba disponible en la interfaz de usuario. El an√°lisis sugiere que esto se debe a una restricci√≥n en las cuentas nuevas o no verificadas de Railway, que a menudo requieren la adici√≥n de un m√©todo de pago como medida de verificaci√≥n de identidad para habilitar funcionalidades avanzadas como el despliegue de im√°genes personalizadas. Por esta raz√≥n, no se pudo completar el despliegue y obtener una URL p√∫blica.

----------

## üöÄ Gu√≠a de Uso e Instalaci√≥n Local

Este proyecto est√° completamente contenerizado, lo que garantiza que correr√° en diferentes m√°quinas sin problemas. El √∫nico requisito es tener **Docker** y **Docker Compose** instalados.

### Paso 1: Clonar el Repositorio
Abre una terminal y clona este repositorio en tu m√°quina.

Bash

```
git clone https://github.com/NC5002/restaurant-delivery-backend.git
cd restaurant-delivery-backend

```

### Paso 2: Iniciar el Sistema

Ejecuta el siguiente comando desde la ra√≠z del proyecto. Docker Compose leer√° el archivo `docker-compose.yml`, descargar√° las im√°genes de los microservicios desde GitHub Container Registry e iniciar√° todo el sistema.

Bash

```
docker-compose up -d

```

Espera uno o dos minutos para que todos los servicios arranquen y se registren en Eureka.

### Paso 3: Verificar que Todo Funciona

Puedes verificar que el sistema est√° corriendo de varias maneras:

-   **Ver los contenedores activos:**
    
    Bash
    
    ```
    docker ps
    
    ```
    
    Deber√≠as ver 5 contenedores corriendo: `mysql`, `discovery`, `gateway`, `catalog` y `order`.
    
-   **Revisar el Dashboard de Eureka:** Abre tu navegador y ve a `http://localhost:8761`. Deber√≠as ver los servicios `CATALOG`, `ORDER` y `GATEWAY` registrados y con estado `UP`.
    

### Paso 4: Probar la API con Postman

Ahora puedes interactuar con la API a trav√©s del Gateway.

**A. Obtener un Token de Autenticaci√≥n** Primero, necesitas un token para acceder a los endpoints protegidos.

-   **M√©todo:** `POST`
    
-   **URL:** `http://localhost:8080/auth/login`
    
-   **Resultado:** Recibir√°s un token JWT. Copia este token.
    

**B. Crear una Categor√≠a**

-   **M√©todo:** `POST`
    
-   **URL:** `http://localhost:8080/catalog/api/v1/categories`
    
-   **Authorization:** En la pesta√±a `Authorization`, selecciona `Bearer Token` y pega el token que copiaste.
    
-   **Body:** (`raw` -> `JSON`)
    
    JSON
    
    ```
    {
        "name": "Bebidas"
    }
    
    ```
    
-   **Resultado:** Un `201 Created` con la nueva categor√≠a.
    

**C. Listar Categor√≠as**

-   **M√©todo:** `GET`
    
-   **URL:** `http://localhost:8080/catalog/api/v1/categories`
    
-   **Authorization:** `Bearer Token` con tu token.
    
-   **Resultado:** Una lista con la categor√≠a "Bebidas" que acabas de crear.
    

¬°Con esto, has verificado que todo el flujo, desde el Gateway hasta la base de datos, funciona correctamente!
